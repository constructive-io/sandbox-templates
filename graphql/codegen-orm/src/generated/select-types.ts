/**
 * Type utilities for select inference
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

export interface ConnectionResult<T> {
  nodes: T[];
  totalCount: number;
  pageInfo: PageInfo;
}

export interface PageInfo {
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor?: string | null;
  endCursor?: string | null;
}

export interface FindManyArgs<TSelect, TWhere, TOrderBy> {
  select?: TSelect;
  where?: TWhere;
  orderBy?: TOrderBy[];
  first?: number;
  last?: number;
  after?: string;
  before?: string;
  offset?: number;
}

export interface FindFirstArgs<TSelect, TWhere> {
  select?: TSelect;
  where?: TWhere;
}

export interface CreateArgs<TSelect, TData> {
  data: TData;
  select?: TSelect;
}

export interface UpdateArgs<TSelect, TWhere, TData> {
  where: TWhere;
  data: TData;
  select?: TSelect;
}

export interface DeleteArgs<TWhere> {
  where: TWhere;
}

/**
 * Recursively validates select objects, rejecting unknown keys.
 *
 * This type ensures that users can only select fields that actually exist
 * in the GraphQL schema. It returns `never` if any excess keys are found
 * at any nesting level, causing a TypeScript compile error.
 *
 * Why this is needed:
 * TypeScript's excess property checking has a quirk where it only catches
 * invalid fields when they are the ONLY fields. When mixed with valid fields
 * (e.g., `{ id: true, invalidField: true }`), the structural typing allows
 * the excess property through. This type explicitly checks for and rejects
 * such cases.
 *
 * @example
 * // This will cause a type error because 'invalid' doesn't exist:
 * type Result = DeepExact<{ id: true, invalid: true }, { id?: boolean }>;
 * // Result = never (causes assignment error)
 *
 * @example
 * // This works because all fields are valid:
 * type Result = DeepExact<{ id: true }, { id?: boolean; name?: boolean }>;
 * // Result = { id: true }
 */
export type DeepExact<T, Shape> = T extends Shape
  ? Exclude<keyof T, keyof Shape> extends never
    ? {
        [K in keyof T]: K extends keyof Shape
          ? T[K] extends { select: infer NS }
            ? Shape[K] extends { select?: infer ShapeNS }
              ? { select: DeepExact<NS, NonNullable<ShapeNS>> }
              : T[K]
            : T[K]
          : never;
      }
    : never
  : never;

/**
 * Infer result type from select configuration
 */
export type InferSelectResult<TEntity, TSelect> = TSelect extends undefined
  ? TEntity
  : {
      [K in keyof TSelect as TSelect[K] extends false | undefined ? never : K]: TSelect[K] extends true
        ? K extends keyof TEntity
          ? TEntity[K]
          : never
        : TSelect[K] extends { select: infer NestedSelect }
          ? K extends keyof TEntity
            ? NonNullable<TEntity[K]> extends ConnectionResult<infer NodeType>
              ? ConnectionResult<InferSelectResult<NodeType, NestedSelect>>
              : InferSelectResult<NonNullable<TEntity[K]>, NestedSelect> | (null extends TEntity[K] ? null : never)
            : never
          : K extends keyof TEntity
            ? TEntity[K]
            : never;
    };
