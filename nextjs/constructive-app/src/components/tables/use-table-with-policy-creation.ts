'use client';

import { useCallback, useState } from 'react';
import { useQueryClient } from '@tanstack/react-query';

import {
	useCreatePolicyField,
	type PolicyFieldType,
} from '@/lib/gql/hooks/schema-builder/policies/use-create-policy-field';
import { databasePoliciesQueryKeys } from '@/lib/gql/hooks/schema-builder/policies/use-database-policies';
import { accessibleDatabasesQueryKeys } from '@/lib/gql/hooks/schema-builder/use-accessible-databases';
import { useCreateTable } from '@/lib/gql/hooks/schema-builder/use-create-table';
import { toBackendPolicyTypeId } from '@/components/policies/template-schema';
import {
	useCreateForeignKeyConstraintMutation,
	useCreatePolicyMutation,
	useCreatePrimaryKeyConstraintMutation,
} from '@sdk/api';

import { buildPolicyData, getAccessModel, type AccessModelId, type AutoGeneratedField } from './access-model-types';

export type CreationStep =
	| 'idle'
	| 'creating-external-table'
	| 'creating-external-fields'
	| 'creating-main-table'
	| 'creating-main-fields'
	| 'creating-relationship'
	| 'creating-policy'
	| 'done'
	| 'error';

export interface CreationProgress {
	step: CreationStep;
	completedSteps: string[];
	currentStepLabel: string;
	error?: string;
}

export interface ExternalTableConfig {
	useExisting: boolean;
	existingTableId?: string;
	existingTableName?: string;
	existingTableSchema?: string;
	/** Field IDs for existing table (key -> fieldId mapping) */
	existingFieldIds?: Record<string, string>;
	newTableName?: string;
}

export interface PolicyConfig {
	name: string;
	roleName: string;
	privilege: string;
	isPermissive: boolean;
	isEnabled: boolean;
	additionalData?: Record<string, unknown>;
}

export interface CreateTableWithPolicyInput {
	modelId: AccessModelId;
	tableName: string;
	databaseId: string;
	schemaId: string;
	schemaName: string;
	fieldNames: Record<string, string>;
	externalTable?: ExternalTableConfig;
	policyConfig?: PolicyConfig;
}

interface CreatedTableResult {
	id: string;
	name: string;
}

const STEP_LABELS: Record<CreationStep, string> = {
	idle: 'Ready',
	'creating-external-table': 'Creating external table...',
	'creating-external-fields': 'Creating external table fields...',
	'creating-main-table': 'Creating table...',
	'creating-main-fields': 'Creating table fields...',
	'creating-relationship': 'Creating relationship...',
	'creating-policy': 'Creating security policy...',
	done: 'Complete',
	error: 'Error',
};

export function useTableWithPolicyCreation() {
	const queryClient = useQueryClient();
	const createTableMutation = useCreateTable();
	const createFieldMutation = useCreatePolicyField();
	const createPolicyMutation = useCreatePolicyMutation();
	const createFkMutation = useCreateForeignKeyConstraintMutation();
	const createPkMutation = useCreatePrimaryKeyConstraintMutation();

	const [progress, setProgress] = useState<CreationProgress>({
		step: 'idle',
		completedSteps: [],
		currentStepLabel: STEP_LABELS.idle,
	});

	const updateProgress = useCallback((step: CreationStep, error?: string) => {
		setProgress((prev) => {
			const completedSteps =
				step === 'error' || step === 'idle'
					? prev.completedSteps
					: prev.step !== 'idle' && prev.step !== 'error' && prev.step !== 'done'
						? [...prev.completedSteps, STEP_LABELS[prev.step]]
						: prev.completedSteps;

			return {
				step,
				completedSteps,
				currentStepLabel: STEP_LABELS[step],
				error,
			};
		});
	}, []);

	const reset = useCallback(() => {
		setProgress({
			step: 'idle',
			completedSteps: [],
			currentStepLabel: STEP_LABELS.idle,
		});
	}, []);

	const createFields = useCallback(
		async (
			tableId: string,
			databaseId: string,
			fields: AutoGeneratedField[],
			fieldNames: Record<string, string>,
		): Promise<Record<string, string>> => {
			const createdFieldIds: Record<string, string> = {};
			for (const field of fields) {
				const fieldName = fieldNames[field.key] || field.defaultName;
				const created = await createFieldMutation.mutateAsync({
					name: fieldName,
					tableId,
					databaseId,
					fieldType: field.type as PolicyFieldType,
				});
				createdFieldIds[field.key] = created.id;
			}
			return createdFieldIds;
		},
		[createFieldMutation],
	);

	const create = useCallback(
		async (input: CreateTableWithPolicyInput): Promise<CreatedTableResult> => {
			const model = getAccessModel(input.modelId);
			let externalTableInfo: { schema: string; tableName: string; tableId: string } | undefined;
			let externalFieldIds: Record<string, string> = {};

			try {
				if (model.externalTable && input.externalTable) {
					if (input.externalTable.useExisting) {
						if (
							!input.externalTable.existingTableName ||
							!input.externalTable.existingTableSchema ||
							!input.externalTable.existingTableId
						) {
							throw new Error('External table selection is required');
						}
						externalTableInfo = {
							schema: input.externalTable.existingTableSchema,
							tableName: input.externalTable.existingTableName,
							tableId: input.externalTable.existingTableId,
						};
					} else {
						if (!input.externalTable.newTableName) {
							throw new Error('External table name is required');
						}

						updateProgress('creating-external-table');
						const extTable = await createTableMutation.mutateAsync({
							name: input.externalTable.newTableName,
							databaseId: input.databaseId,
							schemaId: input.schemaId,
							useRls: true,
						});

						updateProgress('creating-external-fields');
						externalFieldIds = await createFields(
							extTable.id,
							input.databaseId,
							model.externalTable.fields,
							input.fieldNames,
						);

						// Create primary key constraint on the external table's ref key field
						// For Member List: owned_table_ref_key (the 'id' field)
						const pkFieldKey = model.externalTable.fields.find((f) => f.key.includes('ref_key'))?.key;
						if (pkFieldKey && externalFieldIds[pkFieldKey]) {
							await createPkMutation.mutateAsync({
								input: {
									primaryKeyConstraint: {
										databaseId: input.databaseId,
										tableId: extTable.id,
										fieldIds: [externalFieldIds[pkFieldKey]],
										type: 'p',
									},
								},
							});
						}

						externalTableInfo = {
							schema: input.schemaName,
							tableName: extTable.name,
							tableId: extTable.id,
						};
					}
				}

				updateProgress('creating-main-table');
				const mainTable = await createTableMutation.mutateAsync({
					name: input.tableName,
					databaseId: input.databaseId,
					schemaId: input.schemaId,
					useRls: true,
				});

				let mainFieldIds: Record<string, string> = {};
				if (model.fields.length > 0) {
					updateProgress('creating-main-fields');
					mainFieldIds = await createFields(mainTable.id, input.databaseId, model.fields, input.fieldNames);
				}

				// Create FK relationship between main table and external table
				// For Member List: main.this_object_key -> external.owned_table_ref_key
				if (model.externalTable && externalTableInfo) {
					updateProgress('creating-relationship');

					// Find the FK field on main table and the ref field on external table
					const fkFieldKey = model.fields.find((f) => f.key.includes('object_key') || f.key === 'entity_field')?.key;
					const refFieldKey = model.externalTable.fields.find((f) => f.key.includes('ref_key'))?.key;

					if (fkFieldKey && refFieldKey) {
						const fkFieldId = mainFieldIds[fkFieldKey];
						// For new table: use externalFieldIds
						// For existing table: use existingFieldIds passed from the card
						const refFieldId = input.externalTable?.useExisting
							? input.externalTable.existingFieldIds?.[refFieldKey]
							: externalFieldIds[refFieldKey];

						if (fkFieldId && refFieldId) {
							await createFkMutation.mutateAsync({
								input: {
									foreignKeyConstraint: {
										databaseId: input.databaseId,
										tableId: mainTable.id,
										fieldIds: [fkFieldId],
										refTableId: externalTableInfo.tableId,
										refFieldIds: [refFieldId],
										deleteAction: 'a', // NO ACTION
										updateAction: 'a', // NO ACTION
										type: 'f',
									},
								},
							});
						}
					}
				}

				if (model.createsPolicy && input.policyConfig) {
					updateProgress('creating-policy');

					const policyData = buildPolicyData(input.modelId, input.fieldNames, externalTableInfo);
					const mergedPolicyData = { ...policyData, ...input.policyConfig.additionalData };

					await createPolicyMutation.mutateAsync({
						input: {
							policy: {
								databaseId: input.databaseId,
								tableId: mainTable.id,
								name: input.policyConfig.name,
								roleName: input.policyConfig.roleName,
								privilege: input.policyConfig.privilege,
								permissive: input.policyConfig.isPermissive,
								disabled: !input.policyConfig.isEnabled,
								policyType: toBackendPolicyTypeId(input.modelId as Exclude<AccessModelId, 'blank'>),
								data: mergedPolicyData,
							},
						},
					});

					await queryClient.invalidateQueries({
						queryKey: databasePoliciesQueryKeys.byDatabase(input.databaseId),
					});
				}

				// Explicitly refetch and wait for the schema data to be available
				// before returning. This ensures the new table is in the cache
				// when onTableCreated is called.
				await queryClient.refetchQueries({
					queryKey: accessibleDatabasesQueryKeys.all,
				});

				updateProgress('done');
				return { id: mainTable.id, name: mainTable.name };
			} catch (error) {
				const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
				updateProgress('error', errorMessage);
				throw error;
			}
		},
		[
			createTableMutation,
			createFieldMutation,
			createPolicyMutation,
			createFkMutation,
			createPkMutation,
			createFields,
			updateProgress,
			queryClient,
		],
	);

	return {
		create,
		progress,
		reset,
		isPending: progress.step !== 'idle' && progress.step !== 'done' && progress.step !== 'error',
	};
}
