'use client';

import { useMemo } from 'react';

import { getGeneratedFieldMappings, isPerOperationField } from '../policy-config';
import { useFormSchema } from '../policy-hooks';
import type { MergedPolicyType } from '../policy-types';
import { AdvancedSection } from './advanced-section';
import { AutoGeneratedFieldsInfo } from './auto-generated-fields-info';
import { DynamicFormField } from './dynamic-form-field';

interface PolicyConfigFormProps {
	policyType: MergedPolicyType;
	value: Record<string, unknown>;
	onChange: (value: Record<string, unknown>) => void;
	disabled?: boolean;
	/** Hide the auto-generated fields info box */
	hideAutoGeneratedInfo?: boolean;
	/** Show advanced fields inline instead of in collapsible section */
	flattenAdvanced?: boolean;
	/**
	 * Only show per-operation fields (permission, is_admin, is_owner).
	 * Use this in operation edit cards to prevent editing shared params like entity_field.
	 */
	perOperationOnly?: boolean;
}

/**
 * Dynamic form for configuring a policy type.
 *
 * Renders fields based on the policy type's parameterSchema,
 * splits into main and advanced sections based on UI config.
 */
export function PolicyConfigForm({
	policyType,
	value,
	onChange,
	disabled,
	hideAutoGeneratedInfo,
	flattenAdvanced,
	perOperationOnly,
}: PolicyConfigFormProps) {
	const { mainFields: allMainFields, advancedFields: allAdvancedFields } = useFormSchema(policyType);

	// Filter to only per-operation fields if requested
	const mainFields = perOperationOnly
		? allMainFields.filter((f) => isPerOperationField(policyType.name, f.key))
		: allMainFields;
	const advancedFields = perOperationOnly
		? allAdvancedFields.filter((f) => isPerOperationField(policyType.name, f.key))
		: allAdvancedFields;

	const handleFieldChange = (key: string, fieldValue: unknown) => {
		onChange({ ...value, [key]: fieldValue });
	};

	// Build field mappings for inline editing in auto-generated fields info
	// Derived from fieldOverrides where defaultValue matches a generated field name
	const fieldMappings = useMemo(() => getGeneratedFieldMappings(policyType), [policyType]);

	// Get the set of policy keys that are handled by inline editing
	const inlineEditedKeys = useMemo(() => {
		if (!fieldMappings) return new Set<string>();
		return new Set(Object.values(fieldMappings).map((m) => m.policyKey));
	}, [fieldMappings]);

	// Filter out advanced fields that are handled by inline editing
	// Only filter when inline editing is shown (hideAutoGeneratedInfo is false)
	const filteredAdvancedFields = useMemo(() => {
		if (hideAutoGeneratedInfo) return advancedFields;
		return advancedFields.filter((field) => !inlineEditedKeys.has(field.key));
	}, [advancedFields, inlineEditedKeys, hideAutoGeneratedInfo]);

	// Combine all fields if flattenAdvanced is true
	const allFields = flattenAdvanced ? [...mainFields, ...filteredAdvancedFields] : mainFields;

	// Check if we have any non-inline-edited fields to show
	const hasVisibleFields = allFields.length > 0 || (!flattenAdvanced && filteredAdvancedFields.length > 0);

	// In perOperationOnly mode, show "no config" if there are no per-op fields
	// In normal mode, also check generated fields and inline editing
	const hasNoConfig = perOperationOnly
		? !hasVisibleFields
		: !hasVisibleFields && policyType.generatedFields.length === 0 && inlineEditedKeys.size === 0;

	return (
		<div className='space-y-4'>
			{/* Auto-generated fields notice with inline editing */}
			{!hideAutoGeneratedInfo && (
				<AutoGeneratedFieldsInfo
					fields={policyType.generatedFields}
					value={value}
					onChange={handleFieldChange}
					fieldMappings={fieldMappings}
					disabled={disabled}
				/>
			)}

			{/* Main form fields (or all fields if flattened) */}
			{allFields.length > 0 && (
				<div className='space-y-4'>
					{allFields.map((field) => (
						<DynamicFormField
							key={field.key}
							field={field}
							value={value[field.key]}
							onChange={(v) => handleFieldChange(field.key, v)}
							disabled={disabled}
						/>
					))}
				</div>
			)}

			{/* No configuration needed message */}
			{hasNoConfig && (
				<p className='text-muted-foreground text-sm italic'>
					{perOperationOnly
						? 'No additional settings for this operation.'
						: 'This policy type requires no configuration.'}
				</p>
			)}

			{/* Advanced section - only show if not flattened and has non-inline fields */}
			{!flattenAdvanced && filteredAdvancedFields.length > 0 && (
				<AdvancedSection>
					<div className='space-y-4'>
						{filteredAdvancedFields.map((field) => (
							<DynamicFormField
								key={field.key}
								field={field}
								value={value[field.key]}
								onChange={(v) => handleFieldChange(field.key, v)}
								disabled={disabled}
							/>
						))}
					</div>
				</AdvancedSection>
			)}
		</div>
	);
}
