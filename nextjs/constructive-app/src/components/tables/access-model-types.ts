import { Building2, Globe, Grid3X3, Link, Lock, Shield, Unlock, User, UserCheck, Users } from 'lucide-react';

import type { PolicyRole } from '@/components/policies/policies.types';
import type { PolicyTypeId } from '@/components/policies/template-schema';

export type AccessModelId = PolicyTypeId | 'blank';

export type FieldDataType = 'uuid' | 'uuid[]';

export interface AutoGeneratedField {
	key: string;
	defaultName: string;
	type: FieldDataType;
	label: string;
	description: string;
	required: boolean;
}

export interface ExternalTableConfig {
	purpose: string;
	defaultTableName: string;
	fields: AutoGeneratedField[];
	tableKey: string;
	schemaKey: string;
}

export interface PolicyConfigDefaults {
	roleName: PolicyRole;
	privilege: string;
	isPermissive: boolean;
	isEnabled: boolean;
}

export interface AccessModelDefinition {
	id: AccessModelId;
	label: string;
	description: string;
	explanation: string;
	icon: React.ElementType;
	fields: AutoGeneratedField[];
	externalTable?: ExternalTableConfig;
	policyConfig: PolicyConfigDefaults;
	createsPolicy: boolean;
	features: string[];
}

const DEFAULT_POLICY_CONFIG: PolicyConfigDefaults = {
	roleName: 'authenticated',
	privilege: 'SELECT',
	isPermissive: true,
	isEnabled: true,
};

export const ACCESS_MODELS: Record<AccessModelId, AccessModelDefinition> = {
	blank: {
		id: 'blank',
		label: 'Custom Table (Blank)',
		description: 'No fields or RLS policies will be pre-created.',
		explanation: 'Create a table with just a name. Configure fields and security manually.',
		icon: Grid3X3,
		fields: [],
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: false,
		features: ['Manual configuration', 'Full flexibility'],
	},

	AuthzDirectOwner: {
		id: 'AuthzDirectOwner',
		label: 'Owned',
		description: 'Rows belong to a single user.',
		explanation: 'Users can only access rows where the owner field matches their user ID.',
		icon: User,
		fields: [
			{
				key: 'entity_field',
				defaultName: 'owner_id',
				type: 'uuid',
				label: 'Owner field',
				description: 'Stores the ID of the user who owns this row',
				required: true,
			},
		],
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: true,
		features: ['Own Records', 'Fast, simple RLS'],
	},

	OwnedRecords: {
		id: 'OwnedRecords',
		label: 'Organization Scoped',
		description: 'Rows belong to an organization.',
		explanation: "Users can access rows owned by organizations they're members of.",
		icon: Building2,
		fields: [
			{
				key: 'entity_field',
				defaultName: 'org_id',
				type: 'uuid',
				label: 'Organization field',
				description: 'Stores the ID of the organization that owns this row',
				required: true,
			},
		],
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: true,
		features: ['Org Access', 'Roles & Hierarchy'],
	},

	AuthzDirectOwnerAny: {
		id: 'AuthzDirectOwnerAny',
		label: 'Multi-Owner',
		description: 'Rows can have multiple owners.',
		explanation: 'Users can access rows where any of the owner fields matches their user ID.',
		icon: Users,
		fields: [
			{
				key: 'entity_fields',
				defaultName: 'owner_id',
				type: 'uuid[]',
				label: 'Owner fields',
				description: 'Array of user IDs who can access this row',
				required: true,
			},
		],
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: true,
		features: ['Multi Records', 'Shared ownership'],
	},

	AuthzMembershipByField: {
		id: 'AuthzMembershipByField',
		label: 'Role-Based Access',
		description: 'Access based on role at app, org, or group level.',
		explanation: 'Users can access rows if they have the required membership at the specified level.',
		icon: Shield,
		fields: [
			{
				key: 'entity_field',
				defaultName: 'owner_id',
				type: 'uuid',
				label: 'Entity field',
				description: 'Stores the entity ID for membership lookup',
				required: true,
			},
		],
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: true,
		features: ['Role Access', 'Flexible scoping'],
	},

	AuthzMembership: {
		id: 'AuthzMembership',
		label: 'Global Permission',
		description: 'Access when user has a required global right.',
		explanation: 'Users can access all rows if they have the required global or admin permission.',
		icon: Globe,
		fields: [],
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: true,
		features: ['Global access', 'Admin override'],
	},

	AuthzAllowAll: {
		id: 'AuthzAllowAll',
		label: 'Public (Allow All)',
		description: 'All rows are accessible to everyone.',
		explanation: 'No restrictions - all authenticated users can access all rows.',
		icon: Unlock,
		fields: [],
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: true,
		features: ['Public data', 'No restrictions'],
	},

	AuthzDenyAll: {
		id: 'AuthzDenyAll',
		label: 'Private (Deny All)',
		description: 'No rows are accessible.',
		explanation: 'Blocks all access. Useful as a restrictive base policy.',
		icon: Lock,
		fields: [],
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: true,
		features: ['Block all', 'Restrictive base'],
	},

	AuthzArrayContainsActorByJoin: {
		id: 'AuthzArrayContainsActorByJoin',
		label: 'Member List',
		description: 'Access when user is in a member list.',
		explanation: 'Users can access rows linked to records that list them as a member.',
		icon: UserCheck,
		fields: [
			{
				key: 'this_object_key',
				defaultName: 'group_id',
				type: 'uuid',
				label: 'Foreign key',
				description: 'Foreign key linking to the membership table',
				required: true,
			},
		],
		externalTable: {
			purpose: 'Store membership with member arrays',
			defaultTableName: 'groups',
			tableKey: 'owned_table',
			schemaKey: 'owned_schema',
			fields: [
				{
					key: 'owned_table_key',
					defaultName: 'member_ids',
					type: 'uuid[]',
					label: 'Member array column',
					description: 'Array of user IDs who are members',
					required: true,
				},
				{
					key: 'owned_table_ref_key',
					defaultName: 'id',
					type: 'uuid',
					label: 'Primary key',
					description: 'Primary key for referencing',
					required: true,
				},
			],
		},
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: true,
		features: ['Group access', 'Member arrays'],
	},

	AuthzMembershipByJoin: {
		id: 'AuthzMembershipByJoin',
		label: 'Related Owner',
		description: 'Ownership flows through another table.',
		explanation: 'Users can access rows linked to objects owned by entities they have membership to.',
		icon: Link,
		fields: [
			{
				key: 'entity_field',
				defaultName: 'object_id',
				type: 'uuid',
				label: 'Foreign key',
				description: 'Foreign key on this table pointing to the owner table',
				required: true,
			},
			{
				key: 'membership_join_field',
				defaultName: 'entity_id',
				type: 'uuid',
				label: 'Membership join field',
				description: 'Column on this table used to match membership entity ids.',
				required: true,
			},
		],
		externalTable: {
			purpose: 'Owner table containing ownership information',
			defaultTableName: 'objects',
			tableKey: 'obj_table',
			schemaKey: 'obj_schema',
			fields: [
				{
					key: 'sel_field',
					defaultName: 'id',
					type: 'uuid',
					label: 'Join key',
					description: 'Primary key for joining',
					required: true,
				},
				{
					key: 'obj_field',
					defaultName: 'owner_id',
					type: 'uuid',
					label: 'Owner field',
					description: 'Owner/entity field for membership check',
					required: true,
				},
			],
		},
		policyConfig: DEFAULT_POLICY_CONFIG,
		createsPolicy: true,
		features: ['Inherited access', 'Advanced RLS'],
	},
};

export function getAccessModel(id: AccessModelId): AccessModelDefinition {
	return ACCESS_MODELS[id];
}

export function requiresExternalTable(id: AccessModelId): boolean {
	return ACCESS_MODELS[id]?.externalTable !== undefined;
}

export function getAccessModelList(options?: { excludeBlank?: boolean }): AccessModelDefinition[] {
	const models = Object.values(ACCESS_MODELS);
	if (options?.excludeBlank) {
		return models.filter((m) => m.id !== 'blank');
	}
	return models;
}

export function getDefaultFieldNames(id: AccessModelId): Record<string, string> {
	const model = ACCESS_MODELS[id];
	const names: Record<string, string> = {};

	for (const field of model.fields) {
		names[field.key] = field.defaultName;
	}

	if (model.externalTable) {
		for (const field of model.externalTable.fields) {
			names[field.key] = field.defaultName;
		}
	}

	return names;
}

export function buildPolicyData(
	modelId: AccessModelId,
	fieldNames: Record<string, string>,
	externalTableInfo?: {
		schema: string;
		tableName: string;
	},
): Record<string, unknown> {
	const model = ACCESS_MODELS[modelId];
	if (!model.createsPolicy) return {};

	const data: Record<string, unknown> = {};

	for (const field of model.fields) {
		if (field.type === 'uuid[]') {
			data[field.key] = [fieldNames[field.key] || field.defaultName];
		} else {
			data[field.key] = fieldNames[field.key] || field.defaultName;
		}
	}

	if (model.externalTable && externalTableInfo) {
		data[model.externalTable.schemaKey] = externalTableInfo.schema;
		data[model.externalTable.tableKey] = externalTableInfo.tableName;

		for (const field of model.externalTable.fields) {
			data[field.key] = fieldNames[field.key] || field.defaultName;
		}
	}

	return data;
}

export function validateFieldNames(
	modelId: AccessModelId,
	fieldNames: Record<string, string>,
	options?: { includeExternalTable?: boolean },
): { valid: boolean; missingFields: string[] } {
	const model = ACCESS_MODELS[modelId];
	const missingFields: string[] = [];

	for (const field of model.fields) {
		if (field.required && !fieldNames[field.key]?.trim()) {
			missingFields.push(field.key);
		}
	}

	if (options?.includeExternalTable && model.externalTable) {
		for (const field of model.externalTable.fields) {
			if (field.required && !fieldNames[field.key]?.trim()) {
				missingFields.push(field.key);
			}
		}
	}

	return {
		valid: missingFields.length === 0,
		missingFields,
	};
}
