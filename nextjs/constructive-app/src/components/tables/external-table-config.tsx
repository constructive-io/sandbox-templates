'use client';

import { useCallback, useMemo } from 'react';
import { Input } from '@constructive-io/ui/input';
import { Label } from '@constructive-io/ui/label';
import { RadioGroup, RadioGroupItem } from '@constructive-io/ui/radio-group';

import type { PolicyFieldType } from '@/lib/gql/hooks/schema-builder/policies/use-create-policy-field';
import type { PolicyTableData } from '@/lib/gql/hooks/schema-builder/policies/use-database-policies';
import {
	FieldSelectRenderer,
	TableSelectRenderer,
	type FieldCreationContext,
	type FieldOption,
} from '@/components/policies/template-fields/field-renderers';
import type { FieldSchema } from '@/components/policies/template-schema';

import type { AutoGeneratedField, ExternalTableConfig as ExternalTableConfigType } from './access-model-types';

export type ExternalTableMode = 'existing' | 'new';

export interface ExternalTableState {
	mode: ExternalTableMode;
	existingTableId: string;
	existingTableSchema: string;
	existingTableName: string;
	newTableName: string;
	fieldValues: Record<string, string>;
}

export interface ExternalTableConfigProps {
	config: ExternalTableConfigType;
	state: ExternalTableState;
	onChange: (state: ExternalTableState) => void;
	tables: PolicyTableData[];
	schemaName: string;
	databaseId?: string;
	disabled?: boolean;
	onCreateTable?: () => void;
	onCreateField?: (fieldType: PolicyFieldType, context?: FieldCreationContext) => void;
}

function autoGeneratedFieldToSchema(field: AutoGeneratedField): FieldSchema {
	// Note: We intentionally don't set dependsOn because we're passing the correct
	// tableFields directly based on the selected table in ExternalTableConfig
	return {
		key: field.key,
		label: field.label,
		description: field.description,
		type: 'field-select',
		required: field.required,
	};
}

export function ExternalTableConfig({
	config,
	state,
	onChange,
	tables,
	schemaName,
	databaseId,
	disabled = false,
	onCreateTable,
	onCreateField,
}: ExternalTableConfigProps) {
	const userTables = useMemo(() => tables.filter((t) => t.category === 'APP'), [tables]);

	const selectedTable = useMemo(
		() => userTables.find((t) => t.id === state.existingTableId),
		[userTables, state.existingTableId],
	);

	const tableFields: FieldOption[] = useMemo(() => {
		if (!selectedTable?.fields) return [];
		return selectedTable.fields
			.slice()
			.sort((a, b) => (a.fieldOrder ?? 0) - (b.fieldOrder ?? 0))
			.map((f) => ({ name: f.name, type: f.type ?? null }));
	}, [selectedTable]);

	const fieldCreationContext: FieldCreationContext | undefined = useMemo(() => {
		if (!selectedTable) return undefined;
		return {
			databaseId: databaseId || '',
			tableId: selectedTable.id,
			tableName: selectedTable.name,
		};
	}, [selectedTable, databaseId]);

	const handleModeChange = useCallback(
		(mode: ExternalTableMode) => {
			if (mode === 'existing') {
				onChange({
					...state,
					mode,
					existingTableId: '',
					existingTableSchema: '',
					existingTableName: '',
					fieldValues: {},
				});
				return;
			}

			const nextFieldValues: Record<string, string> = {};
			for (const field of config.fields) {
				nextFieldValues[field.key] = field.defaultName;
			}

			onChange({
				...state,
				mode,
				newTableName: state.newTableName || config.defaultTableName,
				fieldValues: Object.keys(state.fieldValues).length > 0 ? state.fieldValues : nextFieldValues,
			});
		},
		[state, onChange, config.fields, config.defaultTableName],
	);

	const handleTableChange = useCallback(
		(tableName: string) => {
			const table = userTables.find((t) => t.name === tableName);
			if (table) {
				onChange({
					...state,
					existingTableId: table.id,
					existingTableSchema: table.schema?.schemaName ?? schemaName,
					existingTableName: table.name,
					fieldValues: {},
				});
			}
		},
		[state, onChange, userTables, schemaName],
	);

	const handleNewTableNameChange = useCallback(
		(name: string) => {
			onChange({
				...state,
				newTableName: name,
			});
		},
		[state, onChange],
	);

	const handleFieldValueChange = useCallback(
		(fieldKey: string, value: string) => {
			onChange({
				...state,
				fieldValues: {
					...state.fieldValues,
					[fieldKey]: value,
				},
			});
		},
		[state, onChange],
	);

	const getTableFieldsForRenderer = useCallback(
		(_schema: string, _table: string): FieldOption[] => tableFields,
		[tableFields],
	);

	const tableSelectSchema: FieldSchema = useMemo(
		() => ({
			key: config.tableKey,
			label: 'Table',
			description: 'Select the related table',
			type: 'table-select',
			required: true,
		}),
		[config.tableKey],
	);

	const renderFieldInput = (field: AutoGeneratedField, isExistingMode: boolean) => {
		// For existing mode, don't prefill - user must select from dropdown
		// For new mode, use default values
		const fieldValue = isExistingMode
			? state.fieldValues[field.key] || ''
			: (state.fieldValues[field.key] ?? field.defaultName);

		if (isExistingMode) {
			const fieldSchema = autoGeneratedFieldToSchema(field);
			return (
				<FieldSelectRenderer
					key={field.key}
					field={fieldSchema}
					value={fieldValue}
					onChange={(v) => handleFieldValueChange(field.key, v)}
					variant='full'
					fields={tableFields}
					tables={userTables}
					data={{}}
					getTableFields={getTableFieldsForRenderer}
					onCreateField={onCreateField}
					fieldCreationContext={fieldCreationContext}
				/>
			);
		}

		return (
			<div key={field.key} className='space-y-1.5'>
				<Label htmlFor={`field-${field.key}`}>
					{field.label}
					{field.required && <span className='text-destructive ml-0.5'>*</span>}
				</Label>
				<Input
					id={`field-${field.key}`}
					value={fieldValue}
					onChange={(e) => handleFieldValueChange(field.key, e.target.value)}
					placeholder={field.defaultName}
					className='font-mono'
					disabled={disabled}
				/>
				{field.description && <p className='text-muted-foreground text-xs'>{field.description}</p>}
			</div>
		);
	};

	const isExistingMode = state.mode === 'existing';

	const sectionTitle = useMemo(() => {
		if (config.tableKey === 'owned_table') return 'Owned table';
		if (config.tableKey === 'obj_table') return 'Owner table';
		return 'Related table';
	}, [config.tableKey]);

	return (
		<div className='space-y-4 rounded-lg border p-4'>
			<div className='space-y-1'>
				<p className='text-sm font-medium'>{sectionTitle}</p>
				<p className='text-muted-foreground text-xs'>{config.purpose}</p>
			</div>

			<RadioGroup
				value={state.mode}
				onValueChange={(v) => handleModeChange(v as ExternalTableMode)}
				className='flex flex-row gap-6'
				disabled={disabled}
			>
				<div className='flex items-center gap-2'>
					<RadioGroupItem value='new' id='ext-create-new' />
					<Label htmlFor='ext-create-new' className='cursor-pointer text-sm'>
						Create new table
					</Label>
				</div>
				<div className='flex items-center gap-2'>
					<RadioGroupItem value='existing' id='ext-use-existing' />
					<Label htmlFor='ext-use-existing' className='cursor-pointer text-sm'>
						Use existing table
					</Label>
				</div>
			</RadioGroup>

			<div className='space-y-3'>
				{isExistingMode ? (
					<TableSelectRenderer
						field={tableSelectSchema}
						value={state.existingTableName}
						onChange={handleTableChange}
						variant='full'
						fields={[]}
						tables={userTables}
						data={{}}
						getTableFields={getTableFieldsForRenderer}
						onCreateTable={onCreateTable}
					/>
				) : (
					<div className='space-y-1.5'>
						<Label htmlFor='ext-new-table-name'>
							Table Name <span className='text-destructive'>*</span>
						</Label>
						<Input
							id='ext-new-table-name'
							value={state.newTableName}
							onChange={(e) => handleNewTableNameChange(e.target.value)}
							placeholder={config.defaultTableName}
							className='font-mono'
							disabled={disabled}
						/>
					</div>
				)}

				{config.fields.map((field) => renderFieldInput(field, isExistingMode))}
			</div>
		</div>
	);
}

export function createInitialExternalTableState(
	config: ExternalTableConfigType | undefined,
	defaultMode: ExternalTableMode = 'new',
): ExternalTableState {
	const fieldValues: Record<string, string> = {};
	if (config) {
		for (const field of config.fields) {
			fieldValues[field.key] = field.defaultName;
		}
	}

	return {
		mode: defaultMode,
		existingTableId: '',
		existingTableSchema: '',
		existingTableName: '',
		newTableName: config?.defaultTableName ?? '',
		fieldValues,
	};
}

export function getExternalTablePolicyData(
	state: ExternalTableState,
	config: ExternalTableConfigType,
	schemaName: string,
): Record<string, string> {
	const data: Record<string, string> = {};

	if (state.mode === 'existing') {
		data[config.schemaKey] = state.existingTableSchema || schemaName;
		data[config.tableKey] = state.existingTableName;
	} else {
		data[config.schemaKey] = schemaName;
		data[config.tableKey] = state.newTableName || config.defaultTableName;
	}

	for (const field of config.fields) {
		data[field.key] = state.fieldValues[field.key] || field.defaultName;
	}

	return data;
}
